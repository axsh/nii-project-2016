## This version seems to work, but Jupyter ignores all output after
## sending SIGINT.  Therefore, our cell code is processed properly
## without "#." and generates output, but this output is ignored and
## not displayed on the notebook.  TODO: modify pexpect code.
## ((Adding "#." is still supported and then output shows))

[ "$already_loaded" = "" ] || {
    echo "Already Loaded"
    return
}

set +m
(
export already_loaded=true

mkpipe()
{
    tmpfifo=/tmp/tmpfifo-$$-$RANDOM
    mkfifo "$tmpfifo"
    exec 92< <(cat "$tmpfifo")
    exec 91>"$tmpfifo"
    rm -f "$tmpfifo"
}
mkpipe

exec 0<&1 # undo automatic setting of fd0 to /dev/null
trap 'echo received-usr1 >>/tmp/usr1 ; echo fakesigint >&91' USR1

# Keep an open file descriptor on this source file so we can
# use lsof to track down processes that do not exit properly.
exec 77<"$BASH_SOURCE"

exec 9<&1
echo $$ >/tmp/bpid

echopat='*echo $?*'

# The code below seems to work, but it may be sensitive to
# the timeout and sleep values.  Hopefully it works well enough
# until we have time to modify the bash_kernel code.

blockingread()
{
   while sleep 0.2; do
      IFS= read -r ln
      if [[ "$ln" == $echopat ]]; then
         # give Jupyter a return code when it asks for one
         echo "0" >&9
         echo -n "$PS1" >&9
         continue
      fi
      [ "$ln" = "" ] && continue
      break
   done
}

readcell_inline()
{
    blockingread
    input="$ln"
    echo -n "$PS2">&9
    # read rest of the cell contents
    echo SIG-startloop0 >>/tmp/usr1
    while true; do
	IFS= read -t 0.2 -r lnr 
        echo SIG-startloop1 >>/tmp/usr1
	## if message sent on pipe && the message is fakesigint && break
	{ read -t 0 f && read f  && echo "$f",SIG >>/tmp/usr1 ;  } 0<&92 && [[ "$f" == *fakesigint* ]] && break

	[ "$lnr" = "" ] && sleep 0.5 && continue
	## somehow get make this next line unnecessary!!!
	[[ "$lnr" == *endofcell* ]] && break
	[[ "$lnr" == \#.* ]] && break
	input="${input}"$'\n'"${lnr}"
	# The problem is this next line.  Jupyter will not send the next line unless
	# PS2 is sent.  But if there are no more lines, then Jupyter will block.
	# Therefore, it is necessary to modify the bash_kernel code to remove the
	# requirement for the endofcell marker.
	echo -n "$PS2">&9
        echo SIG-endloop1 >>/tmp/usr1
	lnr=''
    done
    echo SIG-readcell >>/tmp/usr1
}

readcell() # not used yet
{
    echo "$(readcell_inline; echo "$input")"
}

echo "Ready."
echo -n "$PS1"

basedir="$(pwd)"
new_job_dir()
{
    mkdir -p "$basedir/jobs"
    jobn=1000
    while [ -d "$basedir/jobs/j-$jobn" ]; do
        (( jobn++ ))
    done
    mkdir "$basedir/jobs/j-$jobn"
    echo "$basedir/jobs/j-$jobn"
}

get_step_id()
{
    # first line of the form: # (
    pat='#(*'
    while read ln; do
        nospaces="${ln// /}"
        if [[ "$nospaces" == $pat ]]; then
            afterparen="${nospaces#*\(}"
            id="${afterparen%%\)*}"
            echo "$id"
            return 0
        fi
    done <<<"$1"
    return 255
}

get_cell_command()
{
    # first line of the form: # token1 token2 token3
    # where token1 is a file name in the ./stepdefs directory.
    id="$1"
    inputtoscan="$2"
    pat='#*'
    while read ln; do
        if [[ "$ln" == $pat ]]; then
            read commentchars ln <<<"${ln}"
	fi
        read token1 othertokens <<<"${ln}"
        script_path="$basedir/stepdefs/s-$id/$token1.sh"
        if [ -f "$script_path" ]; then
            echo "$script_path $othertokens"
            return 0
        fi
    done <<<"$inputtoscan"
    return 255
}

# for testing:
while sleep 0.2; do
    ls -l /proc/$BASHPID/fd >>/tmp/sbash.log
    ## TODO: Tracing shows delivery of USR1 signal is delayed. It is probably
    ## because signal delivery is blocked until the process started on the
    ## next line exits.
    readcell_inline
    if [[ "$input" = *quit* ]]; then
      echo "bye"
      # the PS1 will be sent by the parent bash (the one created by jupyter)
      break
    fi

    jd="$(new_job_dir)"
    echo "$input" >"$jd/input"

    didcmd=false
    if stepid="$(get_step_id "$input")"; then
        # set -x
        stepdir="$basedir/stepdefs/s-$stepid"
        if [ -d "$stepdir" ]; then
            if command="$(get_cell_command "$stepid" "$input")"; then
                echo "$command" >"$jd/command"
                echo "$input" | bash $command >"$jd/output" 2>&1
                echo "$?" >"$jd/rc"
                didcmd=true
            fi
        fi
    fi
    if ! $didcmd; then
        # for default, execute code like normal bash cell
        bash "$jd/input" >"$jd/output" 2>&1
        echo "$?" >"$jd/rc"
    fi
    echo "$(cat "$jd/output")"
    echo -n "$PS1"
done
)  &

inputpid="$!"
trap 'echo sent-usr1-$inputpid >>/tmp/usr1 ;  kill -USR1 $inputpid' INT

while  [ -d /proc/$inputpid ]; do
    wait
done

set -m
trap - INT

